/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type std_size_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: i32 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
pub struct std_type_info__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_type_info {
    pub vtable_: *const std_type_info__bindgen_vtable,
    pub __name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_std_type_info() {
    assert_eq!(
        ::std::mem::size_of::<std_type_info>(),
        16usize,
        concat!("Size of: ", stringify!(std_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std_type_info>(),
        8usize,
        concat!("Alignment of ", stringify!(std_type_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_type_info>())).__name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_type_info),
            "::",
            stringify!(__name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info4nameEv"]
    pub fn std_type_info_name(this: *const std_type_info) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info6beforeERKS_"]
    pub fn std_type_info_before(this: *const std_type_info, __arg: *const std_type_info) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info9hash_codeEv"]
    pub fn std_type_info_hash_code(this: *const std_type_info) -> std_size_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9type_infoC1EPKc"]
    pub fn std_type_info_type_info(this: *mut std_type_info, __n: *const ::std::os::raw::c_char);
}
impl std_type_info {
    #[inline]
    pub unsafe fn name(&self) -> *const ::std::os::raw::c_char {
        std_type_info_name(self)
    }
    #[inline]
    pub unsafe fn before(&self, __arg: *const std_type_info) -> bool {
        std_type_info_before(self, __arg)
    }
    #[inline]
    pub unsafe fn hash_code(&self) -> std_size_t {
        std_type_info_hash_code(self)
    }
    #[inline]
    pub unsafe fn new(__n: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_type_info_type_info(__bindgen_tmp.as_mut_ptr(), __n);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info14__is_pointer_pEv"]
    pub fn std_type_info___is_pointer_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info15__is_function_pEv"]
    pub fn std_type_info___is_function_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info10__do_catchEPKS_PPvj"]
    pub fn std_type_info___do_catch(
        this: *mut ::std::os::raw::c_void,
        __thr_type: *const std_type_info,
        __thr_obj: *mut *mut ::std::os::raw::c_void,
        __outer: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info11__do_upcastEPKN10__cxxabiv117__class_type_infoEPPv"]
    pub fn std_type_info___do_upcast(
        this: *mut ::std::os::raw::c_void,
        __target: *const __cxxabiv1___class_type_info,
        __obj_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = std_size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
pub type std_string = std_basic_string<::std::os::raw::c_char>;
pub type std_streamoff = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
pub type std_tuple__Inherited = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple__TC2 {
    pub _address: u8,
}
pub type std_tuple__TCC = u8;
pub type std_tuple__TMC = u8;
pub type std_tuple__TMCT = u8;
pub type std_tuple__TNTC = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl {
    pub _M_t: std_tuple,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___uniq_ptr_impl__Ptr {
    pub _address: u8,
}
pub type std___uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
pub type std___uniq_ptr_impl__DeleterConstraint = u8;
pub type std___uniq_ptr_impl_pointer = std___uniq_ptr_impl__Ptr;
#[repr(C)]
#[derive(Debug)]
pub struct std_unique_ptr {
    pub _M_t: std___uniq_ptr_impl,
}
pub type std_unique_ptr__DeleterConstraint = std___uniq_ptr_impl;
pub type std_unique_ptr_pointer = std___uniq_ptr_impl;
pub type std_unique_ptr_element_type<_Tp> = _Tp;
pub type std_unique_ptr_deleter_type<_Dp> = _Dp;
pub type std_unique_ptr___safe_conversion_up = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_count___not_alloc_shared_tag {
    pub _address: u8,
}
pub type std___shared_count___not_alloc_shared_tag_type = ::std::os::raw::c_void;
extern "C" {
    #[link_name = "\u{1}_M_swap"]
    pub fn std___shared_count__M_swap(this: *mut u8, __r: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}_M_get_use_count"]
    pub fn std___shared_count__M_get_use_count(this: *const u8) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_M_unique"]
    pub fn std___shared_count__M_unique(this: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_M_get_deleter"]
    pub fn std___shared_count__M_get_deleter(
        this: *const u8,
        __ti: *const std_type_info,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_M_less"]
    pub fn std___shared_count__M_less(this: *const u8, __rhs: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_M_less"]
    pub fn std___shared_count__M_less1(this: *const u8, __rhs: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_M_swap"]
    pub fn std___weak_count__M_swap(this: *mut u8, __r: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}_M_get_use_count"]
    pub fn std___weak_count__M_get_use_count(this: *const u8) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_M_less"]
    pub fn std___weak_count__M_less(this: *const u8, __rhs: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_M_less"]
    pub fn std___weak_count__M_less1(this: *const u8, __rhs: *mut u8) -> bool;
}
pub type std___shared_ptr_element_type = std_remove_extent;
pub type std___shared_ptr__SafeConv = u8;
pub type std___shared_ptr__Compatible = u8;
pub type std___shared_ptr__Assignable = std___shared_ptr__Compatible;
pub type std___shared_ptr__UniqCompatible = u8;
pub type std___shared_ptr__UniqAssignable = std___shared_ptr__UniqCompatible;
pub type std___shared_ptr___esft_base_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___shared_ptr___has_esft_base {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = std_size_t;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__Temporary_value {
    pub _M_this: *mut std_vector,
    pub __buf: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = std_size_t;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __int64_t = ::std::os::raw::c_long;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type omega_byte_t = ::std::os::raw::c_uchar;
pub type omega_session_t = omega_session_struct;
pub type omega_change_t = omega_change_struct;
pub type omega_viewport_t = omega_viewport_struct;
pub type size_t = ::std::os::raw::c_ulong;
#[doc = " On session change callback.  This under-defined function will be called when an associated session changes."]
pub type omega_session_on_change_cbk_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const omega_session_t, arg2: *const omega_change_t),
>;
#[doc = " On viewport change callback.  This under-defined function will be called when an associated viewport changes."]
pub type omega_viewport_on_change_cbk_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const omega_viewport_t, arg2: *const omega_change_t),
>;
extern "C" {
    #[doc = " Create a file editing session from a file path"]
    #[doc = " @param file_path file path, will be opened for read, to create an editing session with, or nullptr if starting from"]
    #[doc = " scratch"]
    #[doc = " @param session_on_change_cbk user-defined callback function called whenever a content affecting change is made to"]
    #[doc = " this session"]
    #[doc = " @param user_data_ptr pointer to user-defined data to associate with this session"]
    #[doc = "@return pointer to the created session, nullptr on failure"]
    pub fn omega_edit_create_session(
        file_path: *const ::std::os::raw::c_char,
        cbk: omega_session_on_change_cbk_t,
        user_data_ptr: *mut ::std::os::raw::c_void,
    ) -> *mut omega_session_t;
}
extern "C" {
    #[doc = " Destroy the given session and all associated objects (authors, changes, and viewports)"]
    #[doc = " @param session_ptr session to destroy"]
    pub fn omega_edit_destroy_session(session_ptr: *mut omega_session_t);
}
extern "C" {
    #[doc = " Create a new viewport for the given author, returns a pointer to the new viewport"]
    #[doc = " @param session_ptr author wanting the new viewport"]
    #[doc = " @param offset offset for the new viewport"]
    #[doc = " @param capacity desired capacity of the new viewport"]
    #[doc = " @param cbk user-defined callback function called whenever the viewport gets updated"]
    #[doc = " @param user_data_ptr pointer to user-defined data to associate with this new viewport"]
    #[doc = " @return pointer to the new viewport, nullptr on failure"]
    pub fn omega_edit_create_viewport(
        session_ptr: *mut omega_session_t,
        offset: i64,
        capacity: i64,
        cbk: omega_viewport_on_change_cbk_t,
        user_data_ptr: *mut ::std::os::raw::c_void,
    ) -> *mut omega_viewport_t;
}
extern "C" {
    #[doc = " Save the given session (the edited file) to the given file path"]
    #[doc = " @param session_ptr session to save"]
    #[doc = " @param file_path file path to save to"]
    #[doc = " @return 0 on success, non-zero otherwise"]
    pub fn omega_edit_save(
        session_ptr: *const omega_session_t,
        file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Delete a number of bytes at the given offset"]
    #[doc = " @param session_ptr session to make the change in"]
    #[doc = " @param offset location offset to make the change"]
    #[doc = " @param length number of bytes to delete"]
    #[doc = " @return positive change serial number on success, zero otherwise"]
    pub fn omega_edit_delete(session_ptr: *mut omega_session_t, offset: i64, length: i64) -> i64;
}
extern "C" {
    #[doc = " Insert a C string at the given offset"]
    #[doc = " @param session_ptr session to make the change in"]
    #[doc = " @param offset location offset to make the change"]
    #[doc = " @param cstr C string to insert at the given offset"]
    #[doc = " @param length length of the C string to insert (if 0, strlen will be used to calculate the length of null-terminated"]
    #[doc = " bytes)"]
    #[doc = " @return positive change serial number on success, zero otherwise"]
    pub fn omega_edit_insert(
        session_ptr: *mut omega_session_t,
        offset: i64,
        cstr: *const ::std::os::raw::c_char,
        length: i64,
    ) -> i64;
}
extern "C" {
    #[doc = " Overwrite bytes at the given offset with the given new C string"]
    #[doc = " @param session_ptr session to make the change in"]
    #[doc = " @param offset location offset to make the change"]
    #[doc = " @param cstr new C string to overwrite the old bytes with"]
    #[doc = " @param length length of the new C string (if 0, strlen will be used to calculate the length of null-terminated bytes)"]
    #[doc = " @return positive change serial number on success, zero otherwise"]
    pub fn omega_edit_overwrite(
        session_ptr: *mut omega_session_t,
        offset: i64,
        cstr: *const ::std::os::raw::c_char,
        length: i64,
    ) -> i64;
}
extern "C" {
    #[doc = " Given a viewport, return the viewport data length"]
    #[doc = " @param viewport_ptr viewport to get the viewport data length from"]
    #[doc = " @return viewport data length"]
    pub fn omega_viewport_get_length(viewport_ptr: *const omega_viewport_t) -> i64;
}
extern "C" {
    #[doc = " Given a viewport, return the viewport data"]
    #[doc = " @param viewport_ptr viewport to get the viewport data from"]
    #[doc = " @return viewport data"]
    pub fn omega_viewport_get_data(viewport_ptr: *const omega_viewport_t) -> *const omega_byte_t;
}
extern "C" {
    #[doc = " Given a viewport, return the viewport user data"]
    #[doc = " @param viewport_ptr viewport to get the user data from"]
    #[doc = " @return viewport user data"]
    pub fn omega_viewport_get_user_data(
        viewport_ptr: *const omega_viewport_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Change viewport settings"]
    #[doc = " @param viewport_ptr viewport to change settings on"]
    #[doc = " @param offset offset for the viewport"]
    #[doc = " @param capacity capacity of the viewport"]
    #[doc = " @return 0 on success, non-zero otherwise"]
    pub fn omega_viewport_update(
        viewport_ptr: *mut omega_viewport_t,
        offset: i64,
        capacity: i64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Union to hold consecutive bytes of data.  If the length of the data is less than 8, the data will be stored directly"]
#[doc = " in the sm_bytes field.  If the length is greater than 7, the data will be stored in allocated space on the heap"]
#[doc = " whose address will be stored in the bytes field."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union omega_data_union {
    #[doc = "< Hold bytes of length greater than 7"]
    pub bytes_ptr: *mut omega_byte_t,
    #[doc = "< Hold bytes of length less than 8"]
    pub sm_bytes: [omega_byte_t; 8usize],
}
#[test]
fn bindgen_test_layout_omega_data_union() {
    assert_eq!(
        ::std::mem::size_of::<omega_data_union>(),
        8usize,
        concat!("Size of: ", stringify!(omega_data_union))
    );
    assert_eq!(
        ::std::mem::align_of::<omega_data_union>(),
        8usize,
        concat!("Alignment of ", stringify!(omega_data_union))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_data_union>())).bytes_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_data_union),
            "::",
            stringify!(bytes_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_data_union>())).sm_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_data_union),
            "::",
            stringify!(sm_bytes)
        )
    );
}
#[doc = " Union to hold consecutive bytes of data.  If the length of the data is less than 8, the data will be stored directly"]
#[doc = " in the sm_bytes field.  If the length is greater than 7, the data will be stored in allocated space on the heap"]
#[doc = " whose address will be stored in the bytes field."]
pub type omega_data_t = omega_data_union;
pub const change_kind_t_CHANGE_DELETE: change_kind_t = 0;
pub const change_kind_t_CHANGE_INSERT: change_kind_t = 1;
pub const change_kind_t_CHANGE_OVERWRITE: change_kind_t = 2;
pub type change_kind_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct omega_change_struct {
    #[doc = "< Serial number of the change (increasing)"]
    pub serial: i64,
    #[doc = "< Change kind"]
    pub kind: change_kind_t,
    #[doc = "< Offset at the time of the change"]
    pub offset: i64,
    #[doc = "< Number of bytes at the time of the change"]
    pub length: i64,
    #[doc = "< Bytes to insert or overwrite"]
    pub data: omega_data_t,
}
#[test]
fn bindgen_test_layout_omega_change_struct() {
    assert_eq!(
        ::std::mem::size_of::<omega_change_struct>(),
        40usize,
        concat!("Size of: ", stringify!(omega_change_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<omega_change_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(omega_change_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_change_struct>())).serial as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_change_struct),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_change_struct>())).kind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_change_struct),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_change_struct>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_change_struct),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_change_struct>())).length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_change_struct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_change_struct>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_change_struct),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___class_type_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type omega_model_t = omega_model_struct;
#[doc = " A segment of data"]
pub type omega_data_segment_t = omega_data_segment_struct;
pub type omega_model_segment_t = omega_model_segment_struct;
pub type const_omega_change_ptr_t = std_shared_ptr;
#[doc = " A segment of data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct omega_data_segment_struct {
    #[doc = "< Data offset as changes have been made"]
    pub offset: i64,
    #[doc = "< Populated data length (in bytes)"]
    pub length: i64,
    #[doc = "< Data capacity (in bytes)"]
    pub capacity: i64,
    #[doc = "< Copy of the data itself"]
    pub data: omega_data_t,
}
#[test]
fn bindgen_test_layout_omega_data_segment_struct() {
    assert_eq!(
        ::std::mem::size_of::<omega_data_segment_struct>(),
        32usize,
        concat!("Size of: ", stringify!(omega_data_segment_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<omega_data_segment_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(omega_data_segment_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_data_segment_struct>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_data_segment_struct),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_data_segment_struct>())).length as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_data_segment_struct),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_data_segment_struct>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_data_segment_struct),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_data_segment_struct>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_data_segment_struct),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
pub struct omega_model_segment_struct {
    #[doc = "< Computed offset can differ from the change as segments move and split"]
    pub computed_offset: i64,
    #[doc = "< Computed length can differ from the change as segments split"]
    pub computed_length: i64,
    #[doc = "< Change offset is the offset in the change due to a split"]
    pub change_offset: i64,
    #[doc = "< Reference to parent change"]
    pub change_ptr: const_omega_change_ptr_t,
}
#[test]
fn bindgen_test_layout_omega_model_segment_struct() {
    assert_eq!(
        ::std::mem::size_of::<omega_model_segment_struct>(),
        40usize,
        concat!("Size of: ", stringify!(omega_model_segment_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<omega_model_segment_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(omega_model_segment_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_model_segment_struct>())).computed_offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_model_segment_struct),
            "::",
            stringify!(computed_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_model_segment_struct>())).computed_length as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_model_segment_struct),
            "::",
            stringify!(computed_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_model_segment_struct>())).change_offset as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_model_segment_struct),
            "::",
            stringify!(change_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_model_segment_struct>())).change_ptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_model_segment_struct),
            "::",
            stringify!(change_ptr)
        )
    );
}
pub type omega_model_segment_ptr_t = std_unique_ptr;
pub type omega_model_segments_t = std_vector;
pub type omega_changes_t = std_vector;
#[repr(C)]
pub struct omega_model_struct {
    #[doc = "< Collection of changes for this session, ordered by time"]
    pub changes: omega_changes_t,
    #[doc = "< Undone changes that are eligible for being redone"]
    pub changes_undone: omega_changes_t,
    #[doc = "< Model segment vector"]
    pub model_segments: omega_model_segments_t,
}
#[test]
fn bindgen_test_layout_omega_model_struct() {
    assert_eq!(
        ::std::mem::size_of::<omega_model_struct>(),
        72usize,
        concat!("Size of: ", stringify!(omega_model_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<omega_model_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(omega_model_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_model_struct>())).changes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_model_struct),
            "::",
            stringify!(changes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_model_struct>())).changes_undone as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_model_struct),
            "::",
            stringify!(changes_undone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_model_struct>())).model_segments as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_model_struct),
            "::",
            stringify!(model_segments)
        )
    );
}
pub type omega_model_ptr_t = std_unique_ptr;
pub type omega_viewport_ptr_t = std_shared_ptr;
pub type omega_viewports_t = std_vector;
#[repr(C)]
pub struct omega_session_struct {
    #[doc = "< File being edited (open for read)"]
    pub file_ptr: *mut FILE,
    #[doc = "< File path being edited"]
    pub file_path: std_string,
    #[doc = "< User callback when the session changes"]
    pub on_change_cbk: omega_session_on_change_cbk_t,
    #[doc = "< Pointer to associated user-provided data"]
    pub user_data_ptr: *mut ::std::os::raw::c_void,
    #[doc = "< Collection of viewports in this session"]
    pub viewports_: omega_viewports_t,
    #[doc = "< Edit model (internal)"]
    pub model_ptr_: omega_model_ptr_t,
    #[doc = "< Internal state flags"]
    pub flags_: i8,
}
#[test]
fn bindgen_test_layout_omega_session_struct() {
    assert_eq!(
        ::std::mem::size_of::<omega_session_struct>(),
        96usize,
        concat!("Size of: ", stringify!(omega_session_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<omega_session_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(omega_session_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_session_struct>())).file_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_session_struct),
            "::",
            stringify!(file_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_session_struct>())).file_path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_session_struct),
            "::",
            stringify!(file_path)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_session_struct>())).on_change_cbk as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_session_struct),
            "::",
            stringify!(on_change_cbk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_session_struct>())).user_data_ptr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_session_struct),
            "::",
            stringify!(user_data_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_session_struct>())).viewports_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_session_struct),
            "::",
            stringify!(viewports_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_session_struct>())).model_ptr_ as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_session_struct),
            "::",
            stringify!(model_ptr_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<omega_session_struct>())).flags_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_session_struct),
            "::",
            stringify!(flags_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct omega_viewport_struct {
    #[doc = "< Session that owns this viewport instance"]
    pub session_ptr: *mut omega_session_t,
    #[doc = "< Viewport data"]
    pub data_segment: omega_data_segment_t,
    #[doc = "< User callback when the viewport changes"]
    pub on_change_cbk: omega_viewport_on_change_cbk_t,
    #[doc = "< Pointer to associated user-provided data"]
    pub user_data_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_omega_viewport_struct() {
    assert_eq!(
        ::std::mem::size_of::<omega_viewport_struct>(),
        56usize,
        concat!("Size of: ", stringify!(omega_viewport_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<omega_viewport_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(omega_viewport_struct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_viewport_struct>())).session_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_viewport_struct),
            "::",
            stringify!(session_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_viewport_struct>())).data_segment as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_viewport_struct),
            "::",
            stringify!(data_segment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_viewport_struct>())).on_change_cbk as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_viewport_struct),
            "::",
            stringify!(on_change_cbk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<omega_viewport_struct>())).user_data_ptr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(omega_viewport_struct),
            "::",
            stringify!(user_data_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_shared_ptr_open0_omega_change_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_ptr>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_omega_model_segment_t_std_default_delete_open1_omega_model_segment_struct_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_omega_model_segment_struct_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_omega_model_segment_ptr_t_std_allocator_open1_std_unique_ptr_open2_omega_model_segment_struct_std_default_delete_open3_omega_model_segment_struct_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_unique_ptr_open1_omega_model_segment_struct_std_default_delete_open2_omega_model_segment_struct_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_omega_model_segment_struct_std_default_delete_open1_omega_model_segment_struct_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_omega_model_segment_struct_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_const_omega_change_ptr_t_std_allocator_open1_std_shared_ptr_open2_omega_change_struct_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_shared_ptr_open1_omega_change_struct_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_shared_ptr_open0_omega_change_struct_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_ptr>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_unique_ptr_open0_omega_model_t_std_default_delete_open1_omega_model_struct_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_unique_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_unique_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_default_delete_open0_omega_model_struct_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_default_delete>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_default_delete)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_default_delete>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_default_delete)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_shared_ptr_open0_omega_viewport_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_ptr>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_omega_viewport_ptr_t_std_allocator_open1_std_shared_ptr_open2_omega_viewport_struct_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_shared_ptr_open1_omega_viewport_struct_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_shared_ptr_open0_omega_viewport_struct_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_shared_ptr>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_shared_ptr>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_shared_ptr)
        )
    );
}
